<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DX-Ball Clone</title>
<style>
  body {
    margin: 0;
    font-family: 'Arial', sans-serif;
    background: #111;
    color: #fff;
    text-align: center;
    overflow: hidden;
    cursor: none;
  }
  .page {
    display: none;
    padding: 20px;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    z-index: 10;
  }
  #startPage, #endPage, #victoryPage {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    cursor: auto;
  }
  button {
    padding: 15px 30px;
    margin-top: 30px;
    font-size: 18px;
    border: none;
    border-radius: 8px;
    background: #4CAF50;
    color: white;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s;
  }
  button:hover { 
    background: #45a049;
    transform: scale(1.05);
  }
  canvas {
    display: block;
    margin: 20px auto;
    background: #000;
    border: 2px solid #4CAF50;
    border-radius: 10px;
  }
  #hud {
    margin: 10px 0;
    display: flex;
    justify-content: center;
    gap: 20px;
    font-size: 18px;
    font-weight: bold;
  }
  #hud span {
    padding: 10px 15px;
    background: rgba(76, 175, 80, 0.2);
    border-radius: 5px;
  }
  h1 {
    color: #4CAF50;
    font-size: 36px;
    margin-bottom: 20px;
    text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
  }
  h2 {
    color: #4CAF50;
    font-size: 30px;
    margin-bottom: 20px;
  }
  p {
    font-size: 18px;
    line-height: 1.6;
    max-width: 600px;
  }
  .instructions {
    background: rgba(255, 255, 255, 0.1);
    padding: 20px;
    border-radius: 10px;
    margin: 20px 0;
  }
  #clickToStart {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.7);
    padding: 20px;
    border-radius: 10px;
    border: 2px solid #4CAF50;
    z-index: 5;
    font-size: 24px;
    color: #4CAF50;
  }
</style>
</head>
<body>

<!-- Start Page -->
<div id="startPage" class="page">
  <h1>DX-Ball Clone</h1>
  <div class="instructions">
    <p><strong>Objective:</strong> Destroy all the bricks with your ball!</p>
    <p><strong>Controls:</strong> Move mouse to control paddle, click to launch ball</p>
    <p><strong>Power-ups:</strong> Some help, some hurt. Collect wisely!</p>
    <p><strong>Levels:</strong> Progress through 10 levels to win!</p>
  </div>
  <button onclick="startGame()">Start Game</button>
</div>

<!-- Game Page -->
<div id="gamePage" class="page" style="display: none; background: transparent; z-index: 1;">
  <div id="hud">
    <span id="score">Score: 0</span> 
    <span id="lives">Lives: 3</span> 
    <span id="level">Level: 1</span>
  </div>
  <canvas id="gameCanvas" width="800" height="500"></canvas>
  <div id="clickToStart" style="display: block;">Click to Launch Ball</div>
</div>

<!-- End Page (Game Over) -->
<div id="endPage" class="page">
  <h2>Game Over</h2>
  <p id="finalScore"></p>
  <button onclick="goToStart()">Back to Start</button>
</div>

<!-- Victory Page -->
<div id="victoryPage" class="page">
  <h2>ðŸŽ‰ Victory! ðŸŽ‰</h2>
  <p id="victoryScore"></p>
  <button onclick="goToStart()">Play Again</button>
</div>

<script>
// Page elements
const startPage = document.getElementById("startPage");
const gamePage = document.getElementById("gamePage");
const endPage = document.getElementById("endPage");
const victoryPage = document.getElementById("victoryPage");
const clickToStart = document.getElementById("clickToStart");

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Game state
let score = 0, lives = 3, level = 1;
const MAX_LEVEL = 10;
let paddle, ball, bricks = [], powerUps = [];
let gameRunning = false;
let gamePaused = true;
let animationId = null;

// Mouse position
let mouseX = 0;

// ===== Game Elements =====
function initGameObjects() {
  // Initialize paddle
  paddle = {
    width: 120,
    height: 15,
    x: canvas.width / 2 - 60,
    y: canvas.height - 30,
    defaultWidth: 120
  };
  
  // Initialize ball
  resetBall();
  
  // Create bricks
  createBricks();
  
  // Clear power-ups
  powerUps = [];
}

function createBricks() {
  bricks = [];
  const rows = 3 + Math.min(level, 5);
  const cols = 6 + Math.min(level, 3);
  const brickWidth = (canvas.width - 20) / cols - 2;
  const brickHeight = 25;
  const colors = ['#FF5252', '#FF4081', '#E040FB', '#7C4DFF', '#536DFE', '#448AFF'];
  
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      bricks.push({
        x: c * (brickWidth + 2) + 10,
        y: r * (brickHeight + 2) + 40,
        width: brickWidth,
        height: brickHeight,
        color: colors[r % colors.length],
        broken: false
      });
    }
  }
}

function resetBall() {
  ball = {
    x: paddle.x + paddle.width / 2,
    y: paddle.y - 10,
    size: 8,
    dx: 0,
    dy: 0,
    attached: true // Ball is attached to paddle until launched
  };
}

// ===== PowerUps =====
function spawnPowerUp(x, y) {
  // Higher chance for positive power-ups (70%)
  const types = ["bigPaddle", "extraLife", "slowBall", "bigPaddle", "extraLife", "smallPaddle", "loseLife"];
  const type = types[Math.floor(Math.random() * types.length)];
  
  powerUps.push({
    x: x, 
    y: y, 
    size: 15, 
    dy: 2, 
    type: type,
    color: (type === "bigPaddle" || type === "extraLife" || type === "slowBall") ? "#4CAF50" : "#f00"
  });
}

function applyPowerUp(type) {
  switch(type) {
    case "bigPaddle":
      paddle.width = paddle.defaultWidth * 1.5;
      setTimeout(() => { paddle.width = paddle.defaultWidth; }, 10000);
      break;
    case "smallPaddle":
      paddle.width = paddle.defaultWidth * 0.7;
      setTimeout(() => { paddle.width = paddle.defaultWidth; }, 10000);
      break;
    case "extraLife":
      lives++;
      break;
    case "loseLife":
      lives--;
      break;
    case "slowBall":
      ball.dx *= 0.7;
      ball.dy *= 0.7;
      setTimeout(() => {
        ball.dx /= 0.7;
        ball.dy /= 0.7;
      }, 8000);
      break;
  }
}

function updatePowerUps() {
  for (let i = powerUps.length - 1; i >= 0; i--) {
    const p = powerUps[i];
    
    // Move power-up down
    p.y += p.dy;
    
    // Remove if out of screen
    if (p.y > canvas.height) {
      powerUps.splice(i, 1);
      continue;
    }
    
    // Check collision with paddle
    if (p.y + p.size >= paddle.y &&
        p.x + p.size >= paddle.x &&
        p.x <= paddle.x + paddle.width) {
      applyPowerUp(p.type);
      powerUps.splice(i, 1);
    }
  }
}

function drawPowerUps() {
  powerUps.forEach(p => {
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x + p.size/2, p.y + p.size/2, p.size/2, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw symbol based on power-up type
    ctx.fillStyle = "#000";
    ctx.font = "10px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    
    if (p.type === "bigPaddle") ctx.fillText("B+", p.x + p.size/2, p.y + p.size/2);
    else if (p.type === "smallPaddle") ctx.fillText("B-", p.x + p.size/2, p.y + p.size/2);
    else if (p.type === "extraLife") ctx.fillText("L+", p.x + p.size/2, p.y + p.size/2);
    else if (p.type === "loseLife") ctx.fillText("L-", p.x + p.size/2, p.y + p.size/2);
    else if (p.type === "slowBall") ctx.fillText("S", p.x + p.size/2, p.y + p.size/2);
  });
}

// ===== Collision Detection =====
function checkBrickCollision() {
  for (let i = 0; i < bricks.length; i++) {
    const b = bricks[i];
    if (b.broken) continue;
    
    // Check if ball is colliding with brick
    if (ball.x + ball.size > b.x && 
        ball.x - ball.size < b.x + b.width &&
        ball.y + ball.size > b.y && 
        ball.y - ball.size < b.y + b.height) {
      
      // Determine collision direction and reflect ball
      const ballCenterX = ball.x;
      const ballCenterY = ball.y;
      const brickCenterX = b.x + b.width / 2;
      const brickCenterY = b.y + b.height / 2;
      
      // Calculate overlap on each axis
      const overlapX = Math.min(ball.x + ball.size, b.x + b.width) - Math.max(ball.x - ball.size, b.x);
      const overlapY = Math.min(ball.y + ball.size, b.y + b.height) - Math.max(ball.y - ball.size, b.y);
      
      // Collision from top or bottom
      if (overlapX > overlapY) {
        ball.dy *= -1;
        ball.y += (ballCenterY < brickCenterY) ? -overlapY : overlapY;
      } 
      // Collision from left or right
      else {
        ball.dx *= -1;
        ball.x += (ballCenterX < brickCenterX) ? -overlapX : overlapX;
      }
      
      b.broken = true;
      score += 10;
      
      // 25% chance to spawn power-up
      if (Math.random() < 0.25) {
        spawnPowerUp(b.x + b.width/2, b.y + b.height/2);
      }
      
      return true;
    }
  }
  return false;
}

function checkPaddleCollision() {
  if (ball.y + ball.size < paddle.y || 
      ball.y - ball.size > paddle.y + paddle.height ||
      ball.x + ball.size < paddle.x || 
      ball.x - ball.size > paddle.x + paddle.width) {
    return false;
  }
  
  // Calculate hit position (from -1 to 1)
  const hitPos = (ball.x - (paddle.x + paddle.width/2)) / (paddle.width/2);
  
  // Change angle based on where the ball hits the paddle
  const angle = hitPos * Math.PI/3; // Max 60 degrees
  const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
  
  ball.dx = speed * Math.sin(angle);
  ball.dy = -speed * Math.cos(angle);
  
  return true;
}

// Launch the ball from the paddle
function launchBall() {
  if (ball.attached) {
    ball.attached = false;
    // Set initial velocity based on where the ball is on the paddle
    const hitPos = (ball.x - (paddle.x + paddle.width/2)) / (paddle.width/2);
    const angle = hitPos * Math.PI/3; // Max 60 degrees
    const speed = 4;
    
    ball.dx = speed * Math.sin(angle);
    ball.dy = -speed * Math.cos(angle);
    
    gamePaused = false;
    clickToStart.style.display = 'none';
  }
}

// ===== Game Loop =====
function gameLoop() {
  if (!gameRunning) return;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Update paddle position based on mouse
  paddle.x = mouseX - paddle.width / 2;
  
  // Keep paddle within canvas bounds
  if (paddle.x < 0) paddle.x = 0;
  if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
  
  // Draw paddle
  ctx.fillStyle = "#4CAF50";
  ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
  
  // Draw ball
  ctx.fillStyle = "#f00";
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.size, 0, Math.PI * 2);
  ctx.fill();
  
  // If ball is attached to paddle, keep it on the paddle
  if (ball.attached) {
    ball.x = paddle.x + paddle.width / 2;
  }
  
  // Draw bricks
  bricks.forEach(b => {
    if (!b.broken) {
      ctx.fillStyle = b.color;
      ctx.fillRect(b.x, b.y, b.width, b.height);
      
      // Add brick border
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;
      ctx.strokeRect(b.x, b.y, b.width, b.height);
    }
  });
  
  // Update and draw power-ups
  updatePowerUps();
  drawPowerUps();
  
  // Only update ball position if game is not paused
  if (!gamePaused) {
    // Move ball
    ball.x += ball.dx;
    ball.y += ball.dy;
    
    // Wall collisions
    if (ball.x - ball.size < 0) {
      ball.x = ball.size;
      ball.dx *= -1;
    } else if (ball.x + ball.size > canvas.width) {
      ball.x = canvas.width - ball.size;
      ball.dx *= -1;
    }
    
    if (ball.y - ball.size < 0) {
      ball.y = ball.size;
      ball.dy *= -1;
    }
    
    // Check collisions
    checkBrickCollision();
    checkPaddleCollision();
    
    // Ball fell below paddle
    if (ball.y - ball.size > canvas.height) {
      lives--;
      
      if (lives <= 0) {
        endGame();
        return;
      }
      
      // Pause game and reset ball
      gamePaused = true;
      resetBall();
      clickToStart.style.display = 'block';
    }
  }
  
  // Check if level is cleared
  const levelCleared = bricks.every(b => b.broken);
  if (levelCleared) {
    if (level === MAX_LEVEL) {
      victoryGame();
      return;
    }
    
    level++;
    createBricks();
    resetBall();
    
    // Pause game for next level
    gamePaused = true;
    clickToStart.style.display = 'block';
    
    // Add bonus points for clearing level
    score += 100;
  }
  
  // Update HUD
  document.getElementById("score").textContent = `Score: ${score}`;
  document.getElementById("lives").textContent = `Lives: ${lives}`;
  document.getElementById("level").textContent = `Level: ${level}`;
  
  // Continue game loop
  animationId = requestAnimationFrame(gameLoop);
}

// ===== Mouse Controls =====
canvas.addEventListener("mousemove", (e) => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
});

canvas.addEventListener("click", () => {
  if (gamePaused) {
    launchBall();
  }
});

// ===== Page Navigation =====
function startGame() {
  startPage.style.display = "none";
  endPage.style.display = "none";
  victoryPage.style.display = "none";
  gamePage.style.display = "block";
  
  score = 0;
  lives = 3;
  level = 1;
  
  initGameObjects();
  
  gameRunning = true;
  gamePaused = true;
  animationId = requestAnimationFrame(gameLoop);
}

function endGame() {
  gameRunning = false;
  cancelAnimationFrame(animationId);
  
  gamePage.style.display = "none";
  endPage.style.display = "flex";
  document.getElementById("finalScore").textContent = `Final Score: ${score} | Level Reached: ${level}`;
}

function victoryGame() {
  gameRunning = false;
  cancelAnimationFrame(animationId);
  
  gamePage.style.display = "none";
  victoryPage.style.display = "flex";
  document.getElementById("victoryScore").textContent = `You Won! Final Score: ${score}`;
}

function goToStart() {
  gameRunning = false;
  if (animationId) cancelAnimationFrame(animationId);
  
  endPage.style.display = "none";
  victoryPage.style.display = "none";
  startPage.style.display = "flex";
}

// Initialize the game
window.addEventListener("load", () => {
  startPage.style.display = "flex";
});
</script>
</body>
</html>
