<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DX-Ball Clone</title>
<style>
  body {
    margin: 0;
    font-family: 'Press Start 2P', cursive;
    background: #111;
    color: #0f0;
    text-align: center;
    overflow: hidden;
  }
  .page {
    display: none;
    padding: 20px;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    z-index: 10;
  }
  #startPage, #endPage, #victoryPage {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  button {
    padding: 15px 30px;
    margin-top: 30px;
    font-size: 16px;
    border: none;
    border-radius: 8px;
    background: #0f0;
    color: #111;
    cursor: pointer;
    font-family: 'Press Start 2P', cursive;
  }
  button:hover { 
    background: #6f6; 
    transform: scale(1.05);
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #000;
    border: 2px solid #0f0;
    border-radius: 10px;
  }
  #hud {
    margin: 10px 0;
    display: flex;
    justify-content: center;
    gap: 20px;
  }
  #hud span {
    padding: 8px;
    background: rgba(0, 255, 0, 0.2);
    border-radius: 5px;
  }
</style>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>

<!-- Start Page -->
<div id="startPage" class="page">
  <h1>DX-Ball Clone</h1>
  <p><strong>Objective:</strong> Destroy all the bricks!</p>
  <p><strong>Controls:</strong> Drag on mobile üì± or use ‚¨ÖÔ∏è ‚û°Ô∏è keys on desktop üíª.</p>
  <p><strong>Power-ups:</strong> Some help, some hurt. Collect wisely!</p>
  <p><strong>Levels:</strong> Progress through 10 levels to win üéØ</p>
  <button onclick="startGame()">Start Game</button>
</div>

<!-- Game Page -->
<div id="gamePage" class="page" style="display: none; background: transparent; z-index: 1;">
  <div id="hud">
    <span id="score">Score: 0</span> 
    <span id="lives">Lives: 3</span> 
    <span id="level">Level: 1</span>
  </div>
  <canvas id="gameCanvas"></canvas>
</div>

<!-- End Page (Game Over) -->
<div id="endPage" class="page">
  <h2>Game Over</h2>
  <p id="finalScore"></p>
  <button onclick="goToStart()">Back to Start</button>
</div>

<!-- Victory Page -->
<div id="victoryPage" class="page">
  <h2>üéâ Victory! üéâ</h2>
  <p id="victoryScore"></p>
  <button onclick="goToStart()">Play Again</button>
</div>

<script>
// Page elements
const startPage = document.getElementById("startPage");
const gamePage = document.getElementById("gamePage");
const endPage = document.getElementById("endPage");
const victoryPage = document.getElementById("victoryPage");

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Game state
let score = 0, lives = 3, level = 1;
const MAX_LEVEL = 10;
let paddle, ball, bricks = [], powerUps = [];
let gameRunning = false;
let animationId = null;

// üéµ Sounds - using base64 encoded fallback sounds to avoid external dependencies
const sounds = {
  paddle: new Audio("data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbVtfdJivrJBhNjVgodDbq2EcBStztfLNhTgVABlSqNfDkFgoABUxgK3AtqBwOBIACCyBp8bDnGc1CgAQMoSwyL2ccD8RAAw0g7HLwqJ1PhEADjaFtM3EpHdBEAAQOYe3z8ameEIQABI7ibvRyKp6RBAAFD2LvdPKrHxFEAAWP42/1cyufkYQABhBkMDXzrGASBEBGkOSwdnRtIJKEgEcRZTD29O2hEwTAh5HlsXd1biGTxQDIEmYx9/XuohRFQQiS5rJ4dm8ilMWBSRNnMvj28CMVRcGJk+ez+Xdwo5XGAc+WJzJAAEAAQABAAEAAQA="),
  brick: new Audio("data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbVtfdJivrJBhNjVgodDbq2EcBStztfLNhTgVABlSqNfDkFgoABUxgK3AtqBwOBIACCyBp8bDnGc1CgAQMoSwyL2ccD8RAAw0g7HLwqJ1PhEADjaFtM3EpHdBEAAQOYe3z8ameEIQABI7ibvRyKp6RBAAFD2LvdPKrHxFEAAWP42/1cyufkYQABhBkMDXzrGASBEBGkOSwdnRtIJKEgEcRZTD29O2hEwTAh5HlsXd1biGTxQDIEmYx9/XuohRFQQiS5rJ4dm8ilMWBSRNnMvj28CMVRcGJk+ez+Xdwo5XGAc+WJzJAAEAAQABAAEAAQA="),
  power: new Audio("data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbVtfdJivrJBhNjVgodDbq2EcBStztfLNhTgVABlSqNfDkFgoABUxgK3AtqBwOBIACCyBp8bDnGc1CgAQMoSwyL2ccD8RAAw0g7HLwqJ1PhEADjaFtM3EpHdBEAAQOYe3z8ameEIQABI7ibvRyKp6RBAAFD2LvdPKrHxFEAAWP42/1cyufkYQABhBkMDXzrGASBEBGkOSwdnRtIJKEgEcRZTD29O2hEwTAh5HlsXd1biGTxQDIEmYx9/XuohRFQQiS5rJ4dm8ilMWBSRNnMvj28CMVRcGJk-ez-Xdwo5XGAc-WJzJAAEAAQABAAEAAQA="),
  lose: new Audio("data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbVtfdJivrJBhNjVgodDbq2EcBStztfLNhTgVABlSqNfDkFgoABUxgK3AtqBwOBIACCyBp8bDnGc1CgAQMoSwyL2ccD8RAAw0g7HLwqJ1PhEADjaFtM3EpHdBEAAQOYe3z8ameEIQABI7ibvRyKp6RBAAFD2LvdPKrHxFEAAWP42/1cyufkYQABhBkMDXzrGASBEBGkOSwdnRtIJKEgEcRZTD29O2hEwTAh5HlsXd1biGTxQDIEmYx9/XuohRFQQiS5rJ4dm8ilMWBSRNnMvj28CMVRcGJk-ez-Xdwo5XGAc-WJzJAAEAAQABAAEAAQA="),
  gameover: new Audio("data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbVtfdJivrJBhNjVgodDbq2EcBStztfLNhTgVABlSqNfDkFgoABUxgK3AtqBwOBIACCyBp8bDnGc1CgAQMoSwyL2ccD8RAAw0g7HLwqJ1PhEADjaFtM3EpHdBEAAQOYe3z8ameEIQABI7ibvRyKp6RBAAFD2LvdPKrHxFEAAWP42/1cyufkYQABhBkMDXzrGASBEBGkOSwdnRtIJKEgEcRZTD29O2hEwTAh5HlsXd1biGTxQDIEmYx9/XuohRFQQiS5rJ4dm8ilMWBSRNnMvj28CMVRcGJk-ez-Xdwo5XGAc-WJzJAAEAAQABAAEAAQA="),
  victory: new Audio("data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbVtfdJivrJBhNjVgodDbq2EcBStztfLNhTgVABlSqNfDkFgoABUxgK3AtqBwOBIACCyBp8bDnGc1CgAQMoSwyL2ccD8RAAw0g7HLwqJ1PhEADjaFtM3EpHdBEAAQOYe3z8ameEIQABI7ibvRyKp6RBAAFD2LvdPKrHxFEAAWP42/1cyufkYQABhBkMDXzrGASBEBGkOSwdnRtIJKEgEcRZTD29O2hEwTAh5HlsXd1biGTxQDIEmYx9/XuohRFQQiS5rJ4dm8ilMWBSRNnMvj28CMVRcGJk-ez-Xdwo5XGAc-WJzJAAEAAQABAAEAAQA=")
};

// Set sound volume
Object.values(sounds).forEach(sound => {
  sound.volume = 0.3;
});

// ===== Responsive Canvas =====
function resizeCanvas() {
  canvas.width = Math.min(window.innerWidth * 0.95, 800);
  canvas.height = Math.min(window.innerHeight * 0.7, 500);
  
  if (paddle) {
    // Adjust paddle position and size on resize
    paddle.width = canvas.width * 0.15;
    paddle.x = Math.min(paddle.x, canvas.width - paddle.width);
    
    // Adjust ball position and speed
    if (ball) {
      ball.x = Math.min(ball.x, canvas.width - ball.size);
      ball.y = Math.min(ball.y, canvas.height - ball.size);
      
      // Adjust ball speed based on canvas size
      const baseSpeed = canvas.width * 0.004;
      const speedRatio = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy) / 
                         Math.sqrt(2 * (canvas.width * 0.005) * (canvas.width * 0.005));
      
      ball.dx = (ball.dx > 0 ? 1 : -1) * baseSpeed * speedRatio;
      ball.dy = (ball.dy > 0 ? 1 : -1) * baseSpeed * speedRatio;
    }
  }
}

window.addEventListener("resize", resizeCanvas);

// ===== Game Elements =====
function initGameObjects() {
  // Initialize paddle
  paddle = {
    width: canvas.width * 0.15,
    height: canvas.height * 0.02,
    x: canvas.width / 2 - (canvas.width * 0.15) / 2,
    y: canvas.height - canvas.height * 0.05,
    speed: canvas.width * 0.02,
    defaultWidth: canvas.width * 0.15
  };
  
  // Initialize ball
  resetBall();
  
  // Create bricks
  createBricks();
  
  // Clear power-ups
  powerUps = [];
}

function createBricks() {
  bricks = [];
  const rows = 3 + Math.min(level, 5); // Limit max rows to 8
  const cols = 6 + Math.min(level, 3); // Limit max cols to 9
  const brickWidth = (canvas.width - 20) / cols - 2;
  const brickHeight = canvas.height * 0.035;
  const colors = ['#FF5252', '#FF4081', '#E040FB', '#7C4DFF', '#536DFE', '#448AFF'];
  
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      bricks.push({
        x: c * (brickWidth + 2) + 10,
        y: r * (brickHeight + 2) + 40,
        width: brickWidth,
        height: brickHeight,
        color: colors[r % colors.length],
        broken: false
      });
    }
  }
}

function resetBall() {
  ball = {
    x: canvas.width / 2,
    y: canvas.height - canvas.height * 0.1,
    size: Math.max(canvas.width * 0.012, 6),
    dx: canvas.width * 0.004 * (Math.random() > 0.5 ? 1 : -1),
    dy: -canvas.width * 0.004
  };
}

// ===== PowerUps =====
function spawnPowerUp(x, y) {
  // Higher chance for positive power-ups (70%)
  const types = ["bigPaddle", "extraLife", "slowBall", "bigPaddle", "extraLife", "smallPaddle", "loseLife"];
  const type = types[Math.floor(Math.random() * types.length)];
  
  powerUps.push({
    x: x, 
    y: y, 
    size: canvas.width * 0.02, 
    dy: 3, 
    type: type,
    color: (type === "bigPaddle" || type === "extraLife" || type === "slowBall") ? "#0f0" : "#f00"
  });
}

function applyPowerUp(type) {
  switch(type) {
    case "bigPaddle":
      paddle.width = paddle.defaultWidth * 1.5;
      setTimeout(() => { paddle.width = paddle.defaultWidth; }, 10000);
      break;
    case "smallPaddle":
      paddle.width = paddle.defaultWidth * 0.7;
      setTimeout(() => { paddle.width = paddle.defaultWidth; }, 10000);
      break;
    case "extraLife":
      lives++;
      break;
    case "loseLife":
      lives--;
      break;
    case "slowBall":
      ball.dx *= 0.7;
      ball.dy *= 0.7;
      setTimeout(() => {
        ball.dx /= 0.7;
        ball.dy /= 0.7;
      }, 8000);
      break;
  }
}

function updatePowerUps() {
  for (let i = powerUps.length - 1; i >= 0; i--) {
    const p = powerUps[i];
    
    // Move power-up down
    p.y += p.dy;
    
    // Remove if out of screen
    if (p.y > canvas.height) {
      powerUps.splice(i, 1);
      continue;
    }
    
    // Check collision with paddle
    if (p.y + p.size >= paddle.y &&
        p.x + p.size >= paddle.x &&
        p.x <= paddle.x + paddle.width) {
      applyPowerUp(p.type);
      sounds.power.play();
      powerUps.splice(i, 1);
    }
  }
}

function drawPowerUps() {
  powerUps.forEach(p => {
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x + p.size/2, p.y + p.size/2, p.size/2, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw symbol based on power-up type
    ctx.fillStyle = "#000";
    ctx.font = "10px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    
    if (p.type === "bigPaddle") ctx.fillText("B+", p.x + p.size/2, p.y + p.size/2);
    else if (p.type === "smallPaddle") ctx.fillText("B-", p.x + p.size/2, p.y + p.size/2);
    else if (p.type === "extraLife") ctx.fillText("L+", p.x + p.size/2, p.y + p.size/2);
    else if (p.type === "loseLife") ctx.fillText("L-", p.x + p.size/2, p.y + p.size/2);
    else if (p.type === "slowBall") ctx.fillText("S", p.x + p.size/2, p.y + p.size/2);
  });
}

// ===== Collision Detection =====
function checkBrickCollision() {
  for (let i = 0; i < bricks.length; i++) {
    const b = bricks[i];
    if (b.broken) continue;
    
    // Check if ball is colliding with brick
    if (ball.x + ball.size > b.x && 
        ball.x - ball.size < b.x + b.width &&
        ball.y + ball.size > b.y && 
        ball.y - ball.size < b.y + b.height) {
      
      // Determine collision direction and reflect ball
      const ballCenterX = ball.x;
      const ballCenterY = ball.y;
      const brickCenterX = b.x + b.width / 2;
      const brickCenterY = b.y + b.height / 2;
      
      // Calculate overlap on each axis
      const overlapX = Math.min(ball.x + ball.size, b.x + b.width) - Math.max(ball.x - ball.size, b.x);
      const overlapY = Math.min(ball.y + ball.size, b.y + b.height) - Math.max(ball.y - ball.size, b.y);
      
      // Collision from top or bottom
      if (overlapX > overlapY) {
        ball.dy *= -1;
        ball.y += (ballCenterY < brickCenterY) ? -overlapY : overlapY;
      } 
      // Collision from left or right
      else {
        ball.dx *= -1;
        ball.x += (ballCenterX < brickCenterX) ? -overlapX : overlapX;
      }
      
      b.broken = true;
      score += 10;
      sounds.brick.play();
      
      // 25% chance to spawn power-up
      if (Math.random() < 0.25) {
        spawnPowerUp(b.x + b.width/2, b.y + b.height/2);
      }
      
      return true;
    }
  }
  return false;
}

function checkPaddleCollision() {
  if (ball.y + ball.size < paddle.y || 
      ball.y - ball.size > paddle.y + paddle.height ||
      ball.x + ball.size < paddle.x || 
      ball.x - ball.size > paddle.x + paddle.width) {
    return false;
  }
  
  // Calculate hit position (from -1 to 1)
  const hitPos = (ball.x - (paddle.x + paddle.width/2)) / (paddle.width/2);
  
  // Change angle based on where the ball hits the paddle
  const angle = hitPos * Math.PI/3; // Max 60 degrees
  const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
  
  ball.dx = speed * Math.sin(angle);
  ball.dy = -speed * Math.cos(angle);
  
  sounds.paddle.play();
  return true;
}

// ===== Game Loop =====
function gameLoop() {
  if (!gameRunning) return;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw paddle
  ctx.fillStyle = "#0f0";
  ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
  
  // Draw ball
  ctx.fillStyle = "#f00";
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.size, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw bricks
  bricks.forEach(b => {
    if (!b.broken) {
      ctx.fillStyle = b.color;
      ctx.fillRect(b.x, b.y, b.width, b.height);
      
      // Add brick border
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;
      ctx.strokeRect(b.x, b.y, b.width, b.height);
    }
  });
  
  // Update and draw power-ups
  updatePowerUps();
  drawPowerUps();
  
  // Move ball
  ball.x += ball.dx;
  ball.y += ball.dy;
  
  // Wall collisions
  if (ball.x - ball.size < 0) {
    ball.x = ball.size;
    ball.dx *= -1;
    sounds.paddle.play();
  } else if (ball.x + ball.size > canvas.width) {
    ball.x = canvas.width - ball.size;
    ball.dx *= -1;
    sounds.paddle.play();
  }
  
  if (ball.y - ball.size < 0) {
    ball.y = ball.size;
    ball.dy *= -1;
    sounds.paddle.play();
  }
  
  // Check collisions
  checkBrickCollision();
  checkPaddleCollision();
  
  // Ball fell below paddle
  if (ball.y - ball.size > canvas.height) {
    lives--;
    sounds.lose.play();
    
    if (lives <= 0) {
      endGame();
      return;
    }
    
    resetBall();
  }
  
  // Check if level is cleared
  const levelCleared = bricks.every(b => b.broken);
  if (levelCleared) {
    if (level === MAX_LEVEL) {
      victoryGame();
      return;
    }
    
    level++;
    createBricks();
    resetBall();
    
    // Add bonus points for clearing level
    score += 100;
  }
  
  // Update HUD
  document.getElementById("score").textContent = `Score: ${score}`;
  document.getElementById("lives").textContent = `Lives: ${lives}`;
  document.getElementById("level").textContent = `Level: ${level}`;
  
  // Continue game loop
  animationId = requestAnimationFrame(gameLoop);
}

// ===== Controls =====
let keys = {};
document.addEventListener("keydown", e => {
  keys[e.key] = true;
});

document.addEventListener("keyup", e => {
  keys[e.key] = false;
});

function handlePaddleMovement() {
  if (keys["ArrowLeft"] || keys["a"] || keys["A"]) {
    paddle.x = Math.max(0, paddle.x - paddle.speed);
  }
  if (keys["ArrowRight"] || keys["d"] || keys["D"]) {
    paddle.x = Math.min(canvas.width - paddle.width, paddle.x + paddle.speed);
  }
}

// Touch controls
let touchStartX = 0;
let paddleStartX = 0;

canvas.addEventListener("touchstart", e => {
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  touchStartX = touch.clientX - rect.left;
  paddleStartX = paddle.x;
});

canvas.addEventListener("touchmove", e => {
  e.preventDefault();
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const touchX = touch.clientX - rect.left;
  const deltaX = touchX - touchStartX;
  
  paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddleStartX + deltaX));
});

// ===== Page Navigation =====
function startGame() {
  startPage.style.display = "none";
  endPage.style.display = "none";
  victoryPage.style.display = "none";
  gamePage.style.display = "block";
  
  score = 0;
  lives = 3;
  level = 1;
  
  resizeCanvas();
  initGameObjects();
  
  gameRunning = true;
  animationId = requestAnimationFrame(gameLoop);
}

function endGame() {
  gameRunning = false;
  cancelAnimationFrame(animationId);
  
  gamePage.style.display = "none";
  endPage.style.display = "flex";
  document.getElementById("finalScore").textContent = `Final Score: ${score} | Level Reached: ${level}`;
  sounds.gameover.play();
}

function victoryGame() {
  gameRunning = false;
  cancelAnimationFrame(animationId);
  
  gamePage.style.display = "none";
  victoryPage.style.display = "flex";
  document.getElementById("victoryScore").textContent = `You Won! Final Score: ${score}`;
  sounds.victory.play();
}

function goToStart() {
  gameRunning = false;
  cancelAnimationFrame(animationId);
  
  endPage.style.display = "none";
  victoryPage.style.display = "none";
  startPage.style.display = "flex";
}

// Initialize the game
window.addEventListener("load", () => {
  resizeCanvas();
});

// Handle game updates
setInterval(() => {
  if (gameRunning) {
    handlePaddleMovement();
  }
}, 16); // ~60fps
</script>
</body>
</html>
